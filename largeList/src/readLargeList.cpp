#include "largeList.h"
using namespace Rcpp;
// [[Rcpp::export]]

RcppExport SEXP readLargeList(SEXP fileName, 
                              SEXP index = R_NilValue)
{ 
  //get necessary R functions.
  Environment base("package:base");
  Function unserialize = base["unserialize"];
  Function readBin = base["readBin"];
  Function seek = base["seek"];
  Function file = base["file"];
  Function close = base["close"];
  Function fileInfo = base["file.info"];
  Function readRDS = base["readRDS"];
  
  //if index is not given, use readRDS to get the whole list.
  if (index == R_NilValue){
    SEXP output = readRDS(fileName);
    return(output);
  }else{
  //if not, read only the indicies.
    //check if given index is numeric.
    if (TYPEOF(index) != INTSXP &&  TYPEOF(index) != REALSXP){
      throw std::range_error("Index should be an integer vector");
    }
    //get file length
    Rcpp::DataFrame fileSizeDF(fileInfo(fileName));
    Rcpp::NumericVector fileSizeVec = fileSizeDF[0];
    double fileSize = fileSizeVec[0];
    
    //get length
    SEXP iconRead = file(fileName, "rb");
    seek(iconRead, 18, "start", "read");
    Rcpp::RawVector lengthRawVec = readBin(iconRead, "raw", 4);
    close(iconRead);
    
    //check the range of indicies.
    int lengthOfList = rawVec2Int(lengthRawVec);
    Rcpp::IntegerVector indexVec(index);
    if (min(indexVec) < 1){
      throw std::range_error("Invalid index: index should be positive");
    }
    if (max(indexVec) > (lengthOfList) ){
      throw std::range_error("Invalid index: index beyond list length");
    }
    for(long long int i = 0 ; i < indexVec.size(); i++){
      indexVec[i] = indexVec[i]-1;
    }
    
    //get positions in binary headPositionsRawVec.
    iconRead = file(fileName,"rb");
    seek(iconRead,-8*(lengthOfList+1),"end","read");
    Rcpp::RawVector headPositionsRawVec = readBin(iconRead,"raw",8*(lengthOfList+1));
    close(iconRead);
    
    //get positions.
    long long int headPosition[lengthOfList+1];
    for (long long int i = 0; i< lengthOfList + 1; i++){
      Rcpp::RawVector rawVec(8);
      for(long long int j = 0; j < 8; j++){
        rawVec[j] = headPositionsRawVec[8*i+j];
      }
      headPosition[i] = rawVec2Int(rawVec,8);
      //if head position beyonds file size, throw out error.
      if ((double)headPosition[i] > fileSize){
        Rprintf("index %d ,headPosition %lf, fileSize %lf", i, (double)headPosition[i], fileSize);
        throw std::overflow_error("The file is not generated by saveLargeList function.");
      }
    }
    
    //get new binary list length.
    std::vector<long long int> indexArray = Rcpp::as<std::vector<long long int> >(indexVec);
    long long int indexArraySize = indexArray.size();
    long long int sumLengthRawVec = 22;
    for (long long int i = 0; i < indexArraySize; i++){
      sumLengthRawVec += headPosition[indexArray[i]+1]-headPosition[indexArray[i]];
    }
    
    //build new binary vector to receive raw data.
    Rcpp::RawVector rawVecOutput (sumLengthRawVec);
    iconRead = file(fileName,"rb");
    seek(iconRead,0,"start","read");
    Rcpp::RawVector head = readBin(iconRead, "raw", 18);
    close(iconRead);
    
    //get file head.
    for (long long int i = 0; i < 18; i++){
      rawVecOutput[i] = head[i];
    }
    //get number of element.
    Rcpp::RawVector lengthOfListOutput = int2RawVec(indexArraySize);
    for (long long int i = 0; i < 4; i++){
      rawVecOutput[18+i] = lengthOfListOutput[i];
    }  
    //read element data.
    long long int currentPostion = 22;
    Rcpp::NumericVector positionSXP;
    for (long long int i = 0; i < indexArraySize; i++){
      iconRead = file(fileName,"rb");
      positionSXP = Rcpp::wrap((double)headPosition[indexArray[i]]);
      seek(iconRead, positionSXP, "start", "read");
      positionSXP = Rcpp::wrap((double)(headPosition[indexArray[i]+1]-headPosition[indexArray[i]]));
      Rcpp::RawVector elementRaw = readBin(iconRead, "raw",positionSXP);
      close(iconRead);
      for (long long int j = 0; j < headPosition[indexArray[i]+1]-headPosition[indexArray[i]]; j++){
        rawVecOutput[currentPostion+j] = elementRaw[j];
      }
      currentPostion += headPosition[indexArray[i]+1]-headPosition[indexArray[i]];
    }
    
    //unserialize the raw vector.
    SEXP output = unserialize(rawVecOutput);
    return(output);
  }
}