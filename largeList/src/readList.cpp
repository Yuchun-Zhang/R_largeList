#include "largeList.h"

extern "C" SEXP readList(SEXP file, SEXP index = R_NilValue)
{ 
  //get necessary R functions.
  const char *fileName = CHAR(STRING_ELT(file,0));
  std::fstream fin;
  //if index is not given, use readRDS to get the whole list.
  
  //get file length
  fin.open(fileName, std::ios_base::binary | std::ios_base::in);
  fin.seekg(0, std::ios_base::end);
  int64_t fileSize = fin.tellg();
  
  //get list length
  fin.seekg(18, std::ios_base::beg);
  int lengthOfList;
  fin.read((char*)&(lengthOfList), 4);

  std::vector<int64_t> positions;
  std::vector<int> indexNum;
  std::vector<std::string> names;
  
  //if index not provided
  if (index == R_NilValue){
    indexNum.resize(lengthOfList);
    for(int i = 0 ; i < lengthOfList; i++){
      indexNum[i] = i;
    }
    positions.resize(indexNum.size());
    names.resize(indexNum.size());
    for(int i = 0 ; i < lengthOfList; i++){
      fin.seekg(-2*(8+NAMELENGTH)*lengthOfList-8+(indexNum[i])*(8+NAMELENGTH), std::ios_base::end);
      fin.read((char*)&(positions[i]), 8); 
      names[i].resize(8);
      fin.read((char*)&(names[i][0]),NAMELENGTH);
    }
  }
  
  //check if given index is numeric.
  if (TYPEOF(index) == INTSXP ||  TYPEOF(index) == REALSXP){
    indexNum.resize(Rf_length(index));
    if (TYPEOF(index) == INTSXP){
      indexNum.assign(INTEGER(index),INTEGER(index)+Rf_length(index));
    }else{
      indexNum.assign(REAL(index),REAL(index)+Rf_length(index));
    }
   
    for(int i = 0 ; i < Rf_length(index); i++){
      indexNum[i] = indexNum[i]-1;
    }
    //check the range of indicies
    int maxIndex = *std::max_element(indexNum.begin(), indexNum.end());
    int minIndex = *std::min_element(indexNum.begin(), indexNum.end());
    if (minIndex < 0){
      throw std::range_error("Invalid index: index should be positive");
    }
    if (maxIndex > lengthOfList-1){
      throw std::range_error("Invalid index: index beyonds list length");
    }
    positions.resize(indexNum.size());
    names.resize(indexNum.size());
    for(int i = 0 ; i < Rf_length(index); i++){
      fin.seekg(-2*(8+NAMELENGTH)*lengthOfList-8+(indexNum[i])*(8+NAMELENGTH), std::ios_base::end);
      fin.read((char*)&(positions[i]), 8); 
      names[i].resize(8);
      fin.read((char*)&(names[i][0]),NAMELENGTH);
    }
  }
  
  if (TYPEOF(index) == STRSXP){
    names.resize(Rf_length(index));
    for (int i = 0; i < Rf_length(index); i ++){
      names[i].assign(CHAR(STRING_ELT(index,i)),Rf_length(STRING_ELT(index,i)));
    }
    positions.resize(names.size());
    indexNum.resize(names.size());
    for(int i = 0 ; i < Rf_length(index); i++){
      names[i].resize(8);
      fileBinarySearch(fin,positions[i],names[i],indexNum[i],lengthOfList);
    }
  }
  
  //get elements.
  int64_t indexSize = positions.size();
  SEXP outputList = PROTECT(Rf_allocVector(VECSXP, indexSize));
  for (int i = 0; i <indexSize; i++ ){
    if (positions[i] == -1){
      Rf_warning("Element %s can't be found! \n", names[i].c_str());
      SET_VECTOR_ELT(outputList,i,R_NilValue);
    }else{
      if (positions[i] > fileSize ){
        Rprintf("index %d ,headPosition %lf, fileSize %lf", i, (double)positions[i], (double)fileSize);
        throw std::overflow_error("Head position exceeds file length. Maybe the file is not generated by saveLargeList function.");
      }
      fin.seekg(positions[i], std::ios_base::beg);
      SEXP element = PROTECT(readSEXP(fin));
      SET_VECTOR_ELT(outputList,i,element);
      UNPROTECT_PTR(element);
    }
  }
  SEXP namesSXP = PROTECT(Rf_allocVector(STRSXP, indexSize));
  std::string naString(8,'\xff');
  for (int i = 0; i <indexSize; i++ ){
    if (names[i] == naString){
      SET_STRING_ELT(namesSXP, i, NA_STRING);
    }else{
      SET_STRING_ELT(namesSXP, i, Rf_mkChar(names[i].c_str()));
    }
  }
  Rf_setAttrib(outputList,R_NamesSymbol,namesSXP);
  fin.close(); 
  UNPROTECT(2);
  return(outputList);
}