#include "largeList.h"
using namespace Rcpp;

// [[Rcpp::export]]
RcppExport SEXP readList(SEXP file, 
                         SEXP index = R_NilValue)
{ 
  //get necessary R functions.
  
  std::string fileName = Rcpp::as<std::string>(file);
  std::fstream fin;
  //if index is not given, use readRDS to get the whole list.
  
  //get file length
  fin.open(fileName.c_str(), std::ios_base::binary | std::ios_base::in);
  fin.seekg(0, std::ios_base::end);
  int64_t fileSize = fin.tellg();
  
  //get list length
  fin.seekg(18, std::ios_base::beg);
  int lengthOfList;
  fin.read((char*)&(lengthOfList), 4);

  std::vector<int64_t> positions;
  std::vector<int> indexNum;
  std::vector<std::string> names;
  
  //if index not provided
  if (index == R_NilValue){
    indexNum.resize(lengthOfList);
    for(size_t i = 0 ; i < indexNum.size(); i++){
      indexNum[i] = i;
    }
    positions.resize(indexNum.size());
    names.resize(indexNum.size());
    for(size_t i = 0 ; i < indexNum.size(); i++){
      fin.seekg(-2*(8+NAMELENGTH)*lengthOfList-8+(indexNum[i])*(8+NAMELENGTH), std::ios_base::end);
      fin.read((char*)&(positions[i]), 8); 
      names[i].resize(8);
      fin.read((char*)&(names[i][0]),NAMELENGTH);
    }
  }
  
  //check if given index is numeric.
  if (TYPEOF(index) == INTSXP ||  TYPEOF(index) == REALSXP){
    indexNum = Rcpp::as< std::vector<int> >(index);
    for(size_t i = 0 ; i < indexNum.size(); i++){
      indexNum[i] = indexNum[i]-1;
    }
    //check the range of indicies
    int maxIndex = *std::max_element(indexNum.begin(), indexNum.end());
    int minIndex = *std::min_element(indexNum.begin(), indexNum.end());
    if (minIndex < 0){
      throw std::range_error("Invalid index: index should be positive");
    }
    if (maxIndex > lengthOfList-1){
      throw std::range_error("Invalid index: index beyonds list length");
    }
    positions.resize(indexNum.size());
    names.resize(indexNum.size());
    for(size_t i = 0 ; i < indexNum.size(); i++){
      fin.seekg(-2*(8+NAMELENGTH)*lengthOfList-8+(indexNum[i])*(8+NAMELENGTH), std::ios_base::end);
      fin.read((char*)&(positions[i]), 8); 
      names[i].resize(8);
      fin.read((char*)&(names[i][0]),NAMELENGTH);
    }
  }
  
  if (TYPEOF(index) == STRSXP){
    names = Rcpp::as<std::vector<std::string> >(index);
    positions.resize(names.size());
    indexNum.resize(names.size());
    for(size_t i = 0 ; i < names.size(); i++){
      names[i].resize(8);
      fileBinarySearch(fin,positions[i],names[i],indexNum[i],lengthOfList);
    }
  }
  
  //get elements.
  int64_t indexSize = positions.size();
  List outputList(indexSize);
  for (int i = 0; i <indexSize; i++ ){
    if (positions[i] == -1){
      Rf_warning("Element %s can't be found! \n", names[i].c_str());
      outputList[i] = R_NilValue;
    }else{
      if (positions[i] > fileSize ){
        Rprintf("index %d ,headPosition %lf, fileSize %lf", i, (double)positions[i], (double)fileSize);
        throw std::overflow_error("Head position exceeds file length. Maybe the file is not generated by saveLargeList function.");
      }
      fin.seekg(positions[i], std::ios_base::beg);
      SEXP element;
      readSEXP(element,fin);
      outputList[i] = element;
    }
  }
  StringVector namesSXP(indexSize);
  std::string naString(8,'\xff');
  for (int i = 0; i <indexSize; i++ ){
    if (names[i] == naString){
      namesSXP[i] = NA_STRING;
    }else{
      namesSXP[i] = names[i];
    }
  }
  Rf_setAttrib(outputList,R_NamesSymbol,namesSXP);
  fin.close(); 
  return(outputList);
}